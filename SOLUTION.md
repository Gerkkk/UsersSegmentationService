## Описание выбранных методов решения задачи

#### Что нужно обрабатывать? 

- Создание сегмента
- Редактирование сегмента
- Удаление сегмента и его отмена для всех участвующих пользователей
- Распространение сегмента на заданный процент пользователей (возможно, с некоторым условием)
- Создание нового пользователя
- Удаление пользователя из системы
- Получение списка экспериментов пользователя
- Получение статистики сегмента (сколько пользователей участвуют в сегменте, все данные об этом сегменте)

#### Какие ограничения?

Понимаем, что пользователей много (несколько миллионов), сегментов на несколько порядков меньше (в пределах 1000)

Понятно, что наш сервис будет запрашиваться при каждой авторизации пользователя в приложении (чтобы правильно отрисовать UI в соответствии со всеми сегментами, чтобы выполнить другую логику, связанную с сегментами). Поэтому время ответа на частые запросы должно быть минимальным. 

#### Идеи решения

1) Отметим, что самые частые запросы к нашему сервису - это получение списка сегментов для пользователя, добавление нового пользователя в систему. Поэтому все оптимизации будем проводить так, чтобы улучшить работу, в первую очередь, на этих запросах. 

2) Заметим, что в нашей системе предполагаются две сущности: пользователи и сегменты, а также есть связь n к m для этих сущностей. На этой системе предполагается совершать все типы CRUD-запросов. Также мы работаем с данными пользователей, от нашего сервиса напрямую зависит картинка, которую пользователь увидит на экране. Поэтому важна консистентность данных. Из всего этого следует, что предпочтительнее будет использовать реляционную бд, как хранилище. Но хранить миллиарды (пользователей примерно $10^6$, сегментов до 1000, в худшем случае записей примерно $10^9$) записей в одной таблице не рационально. Поэтому мы будем использовать шардировние нашей реляционной бд. Для этой цели есть удобное поле user_id, известное нам заранее, которое гарантированно разбивает пользователей на примерно равные группы по остатком по модулю числа шардов. При этом операции добавления пользователя и получения пользователя по id будут затрагивать только один шард, и поэтому их можно будет делать быстро. Для более безопасного применения изменений либо ко всем шардам, либо ни к каким, мы будем использовать паттерн 2PC (2 phase commit), пользуясь соответствующими функциями Postgres. Конечно, при таком подходе мы не исключаем полностью возможность применения изменений не ко всем шардам, но мы значительно снижаем вероятность такого события. 

3) Разберемся, как мы будем получать каждый тип запросов. Нередко в микросервисных приложениях есть отдельный сервис ApiGateway, принимающий http-запросы и отправляющий их к конкретным сервисам. Будем считать, что в нашем приложении такой есть. Тогда с синхронными запросами к нашему сервису он будет стучаться с помощью grpc-запросов, которые являются более производительным аналогом http. Также среди наших usecase-ов есть события всей системы, которые наш сервис будет асинхронно обрабатывать, вычитывая из соответствующих топиков брокера сообщений (мы будем предполагать, что в проекте используется kafka). Распишем, какие запросы являются синхронными, а какие - асинхронными:


- Создание сегмента -- синхронное (grpc)
- Редактирование сегмента -- синхронное (grpc)
- Удаление сегмента и его отмена для всех участвующих пользователей -- синхронное (grpc)
- Распространение сегмента на заданный процент пользователей -- синхронное (grpc)
- Создание нового пользователя -- асинхронное (получаем, читая топик create-user, который заполняет сервис авторизации)
- Удаление пользователя -- асинхронное (получаем, читая топик delete-user, который заполняет сервис авторизации)
- Получение списка экспериментов пользователя -- синхронное(grpc)
- Получение статистики сегмента -- синхронное(grpc)

4) Заметим, что в нашей системе изменения сегментов происходят гораздо реже, чем запросы на сегменты пользователя. Поэтому, для ускорения ответов на запросы о сегментах пользователя, будем кэшировать списки сегментов пользователей и инвалидировать кэш при запросах на изменение сегментов и на удаление пользователей.


#### Возможности и идеи по расширению 

* Можно достаточно просто добавлять новые поля в таблицы, расширяя соответствующие структуры и слегка меняя основные запросы
* Можно добавлять поддержку новых событий в системе, например, пометка пользователя как хорошего тестировщика или как плохого. 
* Можно написать больше функциональных и юнит-тестов
* Можно добавить запрос, который возвращает список всех существующих сегментов с информацией о них. Это было бы полезно для панели администратора сегментов.